

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>interpreter.interpreter &mdash; LILI Interpreter 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="LILI Interpreter 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../index.html" class="icon icon-home"> LILI Interpreter
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../wntest.html">wntest module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interpreter.html">interpreter module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interpreterdemo.html">interpreter module demo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../interpreterdemo.html#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../interpreterdemo.html#preprocessing-and-action-detection">Preprocessing and Action Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../interpreterdemo.html#extracting-objects-from-the-command">Extracting Objects from the Command</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../extractor.html">extractor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../terms.html">Terminology</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">LILI Interpreter</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>interpreter.interpreter</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for interpreter.interpreter</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">extractor</span>

<span class="c"># Perform any preprocessing tasks on the text - currently only tokenizes text</span>
<div class="viewcode-block" id="preprocess_text"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.preprocess_text">[docs]</a><span class="k">def</span> <span class="nf">preprocess_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses a raw text sentence. Currently only tokenizes the sentence.</span>

<span class="sd">    Used to do any preprocessing on a sentence in raw text. Currently, the only preprocessing operation is tokenizing the sentence into individual words and punctuation marks.</span>

<span class="sd">    Args:</span>
<span class="sd">        sent (str): A string containing a command sentence</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of preprocessed tokens from the sentence</span>

<span class="sd">    Note:</span>
<span class="sd">        Do not do any part of speech tagging in this function. It is a compute-intensive task and may not be needed for all commands (i.e. erroneous situations).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="extract_action"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.extract_action">[docs]</a><span class="k">def</span> <span class="nf">extract_action</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">known_actions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the :ref:`action &lt;action&gt;` that LILI can respond to, given a tokenized command sentence and a list of known actions.</span>

<span class="sd">    The action is most likely one of the first couple of words of the command, so the sentence is processed from first word to last word. Each word in the sentence is searched for in the given list of known actions. The first word that is found in the known actions array is determined to be the action, and processing ends. A binary search algorithm is used to search for the word to keep processing time short even with large lists of known actions.</span>

<span class="sd">    A tuple that contains two values is returned:</span>

<span class="sd">       1. The action&#39;s :ref:`action set index value &lt;action-set-index&gt;`</span>
<span class="sd">       2. The position of the found word in the sentence represented as an index value</span>

<span class="sd">    Args:</span>
<span class="sd">        sent (list): A list containing the tokenized sentence</span>
<span class="sd">        known_actions (list): A list of tuples ``(str, int)``, each containing the string of a known action and its action set index</span>

<span class="sd">    Returns:</span>
<span class="sd">        (int, int): A tuple that contains the action&#39;s set index and position in the command sentence</span>

<span class="sd">           * Returns (-1, 0) if no action is found</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">token_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">sent</span><span class="p">:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">search_res</span> <span class="o">=</span> <span class="n">binary_search_actions</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">known_actions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">search_res</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">search_res</span><span class="p">,</span> <span class="n">token_index</span><span class="p">)</span>
    <span class="c"># If no main action is found, return (-1,0)</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="binary_search_actions"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.binary_search_actions">[docs]</a><span class="k">def</span> <span class="nf">binary_search_actions</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binary search to find a ``target`` word in a ``pool`` of possibilities.</span>

<span class="sd">    This binary search is used to find a target word with fast performance even with a large search pool. It is implemented recursively to provide a simpler implementation. It assumes that the known actions list is sorted in descending (A to Z) order.</span>

<span class="sd">    Args:</span>
<span class="sd">        target (str): The word to search for</span>
<span class="sd">        pool (list): A list of tuples ``(str, int)``, each containing the string of a known :ref:`action &lt;action&gt;` and its :ref:`action set index &lt;action-set-index&gt;`</span>

<span class="sd">    Return:</span>
<span class="sd">        int: The action set index of the ``target`` word if it is found in the ``pool``</span>

<span class="sd">           * Returns -1 if no match is found</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># If the search pool has been exhausted, the target is not in the pool</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c"># Gets middle index of the remaining pool</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">pool</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="c"># Target must be in lower half of pool</span>
        <span class="k">return</span> <span class="n">binary_search_actions</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pool</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">pool</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="c"># Target must be in higher half of pool</span>
        <span class="k">return</span> <span class="n">binary_search_actions</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pool</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span> <span class="c"># Match has been found</span>
        <span class="k">return</span> <span class="n">pool</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="generate_object_dict"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.generate_object_dict">[docs]</a><span class="k">def</span> <span class="nf">generate_object_dict</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">action_tuple</span><span class="p">,</span> <span class="n">object_extractor_functions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an :ref:`object dictionary &lt;object-dictionary&gt;` according to the provided :ref:`action &lt;action&gt;`.</span>

<span class="sd">    Begins by part of speech tagging the sentence, then trimming the action out of the sentence so that it is not re-processed (depending on implementation details, the presence of the main action in the sentence may throw off results). Then calls the appropriate :ref:`object extractor function &lt;object-extractor-function&gt;` to create the object dictionary. The called object extractor is determined by the action&#39;s :ref:`set index value &lt;action-set-index&gt;`.</span>

<span class="sd">    Args:</span>
<span class="sd">        sent (list): A list containing tokens of the command sentence</span>
<span class="sd">        action_tuple (int, int): A tuple ``(action_set_index, position_in_sent)``:</span>

<span class="sd">           1. ``action_set_index`` - The action&#39;s action set index</span>
<span class="sd">           2. ``position_in_sent`` - An index representing the action&#39;s position in the command sentence</span>

<span class="sd">           * This tuple is in the same format as the return value of :meth:`~interpreter.interpreter.extract_action`</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: An object dictionary for the command</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Tag the sentence with parts of speech</span>
    <span class="n">tagged_sent</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">pos_tag</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>

    <span class="c"># Output for debugging</span>
    <span class="sd">&quot;&quot;&quot;print &quot;Tagged sentence:&quot;</span>
<span class="sd">    print tagged_sent&quot;&quot;&quot;</span>

    <span class="c"># Remove the main action from the sentence - it does not need to be considered when extracting objects</span>
    <span class="c"># If problems occur later down the road, maybe get rid of the action and everything behind it as well</span>
    <span class="c"># Can&#39;t think of any important text that could come before the main action</span>
    <span class="n">trimmed_sent</span> <span class="o">=</span> <span class="n">tagged_sent</span><span class="p">[:</span><span class="n">action_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">tagged_sent</span><span class="p">[</span><span class="n">action_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c"># Call the main action&#39;s corresponding function extractor</span>
    <span class="n">object_dict</span> <span class="o">=</span> <span class="n">object_extractor_functions</span><span class="p">[</span><span class="n">action_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]](</span><span class="n">trimmed_sent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">object_dict</span>
</div>
<div class="viewcode-block" id="generate_json"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.generate_json">[docs]</a><span class="k">def</span> <span class="nf">generate_json</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">object_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a JSON string representation of an :ref:`object dictionary &lt;object-dictionary&gt;` with an entry for the action&#39;s :ref:`set index &lt;action-set-index&gt;`</span>

<span class="sd">    First adds the :ref:`action &lt;action&gt;` and its set index to the object dictionary, then uses the ``json`` module to dump the final dictionary into a JSON string.</span>

<span class="sd">    Args:</span>
<span class="sd">        action (int): The set index of the action</span>
<span class="sd">        object_dict (dict): The object dictionary to be converted to a JSON string</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A JSON string representation of the object dictionary and the action set index</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">object_dict</span>
    <span class="n">result</span><span class="p">[</span><span class="s">&quot;action&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">action</span>
    <span class="k">return</span> <span class="n">result</span>
    <span class="c">#return json.dumps(result)</span>
</div>
<div class="viewcode-block" id="build_action_structures"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.build_action_structures">[docs]</a><span class="k">def</span> <span class="nf">build_action_structures</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a filename that contains a list of known :ref:`actions &lt;action&gt;`, generates the data structures needed to interpret commands.</span>

<span class="sd">    Opens a file of known actions, where each action set is represented on one line (see :ref:`this part of the interpreter demo &lt;initial-setup&gt;` for details on the input file). For each word in this file, a tuple *(str, int)* is generated that contains that word along with its :ref:`action set index &lt;action-set-index&gt;`. This tuple is then appended to the list of known actions. This list is sorted by A-Z order before it is returned to prepare it for binary search operations.</span>

<span class="sd">    A list of :ref:`object extractor functions &lt;object-extractor-function&gt;` is created to correspond to the action set indices be called later on. For each line, another function is added to the extractor function list. To determine the name of the extractor function to be added next, the first word in the action set is appended to the end of the string ``&quot;object_dict\_&quot;``. Once the function name string is built, the function is retreived from the extractor module and is appended to the extractor function list.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (str): The name of the file that contains the list of known actions</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list, list): A tuple ``(known_actions, object_extractor_functions)`` containing:</span>

<span class="sd">           1. ``known_actions`` - The list of tuples each containing a known action and its set index</span>
<span class="sd">           2. ``object_extractor_functions`` - The list of object extractor functions whose list indices correspond with the appropriate action set indices</span>

<span class="sd">    Note:</span>
<span class="sd">        This function only needs to run when the input file is updated. It should not be run every time a new command needs to be interpreted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Initializing data structures</span>
    <span class="n">known_actions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">object_dict_functions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Start reading input file of known actions</span>
    <span class="n">inp_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inp_file</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c"># Checks to make sure the line isn&#39;t an empty string after trimming whitespace</span>
        <span class="c"># Blank lines are ignored completely</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">actions</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
            <span class="c"># Checks to make sure there is at least one action, avoid exception</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">actions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="s">&quot;object_dict_&quot;</span> <span class="o">+</span> <span class="n">actions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c"># Gets the corresponding object extractor function from the extractor module and adds it to the list to be returned</span>
                    <span class="n">object_dict_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">extractor</span><span class="p">,</span> <span class="n">func_name</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">actions</span><span class="p">:</span>
                        <span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="c"># Add each known action and its action set index to the list to be returned</span>
                        <span class="n">known_actions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">action</span><span class="p">,</span> <span class="n">line_num</span><span class="p">))</span>
                    <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c"># Occurs if getattr fails</span>
                    <span class="k">print</span> <span class="s">&quot;Error: There is no object extraction function called &quot;</span> <span class="o">+</span> <span class="n">func_name</span>
                <span class="k">except</span> <span class="ne">StandardError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span> <span class="c"># Catches any other error</span>
                    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

    <span class="c"># Sorts the list of known actions by A-Z alphabetical order</span>
    <span class="n">known_actions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">known_actions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">known_actions</span><span class="p">,</span> <span class="n">object_dict_functions</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="test_sent"><a class="viewcode-back" href="../../interpreter.html#interpreter.interpreter.test_sent">[docs]</a><span class="k">def</span> <span class="nf">test_sent</span><span class="p">(</span><span class="n">sent_text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the order of execution (pipeline) of interpreting a sentence - utilized for checking test cases</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;Preprocessing this sentence:&quot;</span>
    <span class="k">print</span> <span class="n">sent_text</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="n">preprocess_text</span><span class="p">(</span><span class="n">sent_text</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Tokenized:&quot;</span>
    <span class="k">print</span> <span class="n">sent</span>
    <span class="n">action_tuple</span> <span class="o">=</span> <span class="n">extract_action</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">known_actions</span><span class="p">)</span>

    <span class="c"># If this occurred, the action was not recognized</span>
    <span class="k">if</span> <span class="n">action_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;error&quot;</span><span class="p">:</span><span class="s">&quot;Main action not found&quot;</span><span class="p">}</span>
        <span class="c">#return json.dumps(error_dict)</span>
        <span class="k">return</span> <span class="n">error_dict</span>

    <span class="k">print</span> <span class="s">&quot;Action Tuple:&quot;</span>
    <span class="k">print</span> <span class="n">action_tuple</span>
    <span class="n">object_dict</span> <span class="o">=</span> <span class="n">generate_object_dict</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">action_tuple</span><span class="p">,</span> <span class="n">object_extractor_functions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generate_json</span><span class="p">(</span><span class="n">action_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object_dict</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</div>
<span class="sd">&quot;&quot;&quot;res = build_action_structures(&quot;known_actions.txt&quot;)</span>
<span class="sd">known_actions = res[0]</span>
<span class="sd">object_extractor_functions = res[1]</span>

<span class="sd">print str(known_actions)</span>
<span class="sd">print str(object_extractor_functions)</span>
<span class="sd">print str(test_sent(&quot;Blorggdfslgk me to play tennis&quot;))&quot;&quot;&quot;</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Brandon Gottlob.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>