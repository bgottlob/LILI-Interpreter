% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{LILI Interpreter Documentation}
\date{July 08, 2015}
\release{1.0}
\author{Brandon Gottlob}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


The primary goal of this project is to make LILI more intelligent when given voice commands in English. LILI currenty understands only a handful of commands, and these commands must be given the exact expected sentence structure. The LILI Interpreter makes it possible for LILI to understand an open vocabulary of words in more ambiguous sentence structures.

Contents:


\chapter{wntest module}
\label{wntest:welcome-to-lili-interpreter-s-documentation}\label{wntest:module-semsim.wntest}\label{wntest::doc}\label{wntest:wntest-module}\index{semsim.wntest (module)}\index{SemanticSimilarityResult (class in semsim.wntest)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult}\pysiglinewithargsret{\strong{class }\code{semsim.wntest.}\bfcode{SemanticSimilarityResult}}{\emph{unknown}, \emph{known}, \emph{unknown\_synset}, \emph{known\_synset}, \emph{unknown\_definition}, \emph{known\_definition}, \emph{sem\_sim\_score}}{}
This class is used to package results from semantic similarity tests. Each object of this class holds the result of a single unknown to known word mapping.

This class stores a variety of information for analysis purposes, including the synsets with the highest similarity score, their definitions, the semantic similarity score, and most importantly the known word that the unknown word will map to. This class is to be used for testing and analysis purposes to see how the semantic similarity measure may be improved. The only pieces of information important to the final result of the LILI interpreter is the known word that the unknown word is mapped to.
\index{unknown (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.unknown}\pysigline{\bfcode{unknown}}
\emph{str}

The unknown word that has been mapped to a known word

\end{fulllineitems}

\index{known (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.known}\pysigline{\bfcode{known}}
\emph{str}

The known word that has been mapped to

\end{fulllineitems}

\index{unknown\_synset (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.unknown_synset}\pysigline{\bfcode{unknown\_synset}}
\emph{wn.Synset}

The synset of the unknown word

\end{fulllineitems}

\index{known\_synset (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.known_synset}\pysigline{\bfcode{known\_synset}}
\emph{wn.Synset}

The synset of the known word that has been mapped to

\end{fulllineitems}

\index{unknown\_defintion (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.unknown_defintion}\pysigline{\bfcode{unknown\_defintion}}
\emph{str}

The definition of unknown\_synset

\end{fulllineitems}

\index{known\_definition (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.known_definition}\pysigline{\bfcode{known\_definition}}
\emph{str}

The definition of known\_synset

\end{fulllineitems}

\index{sem\_sim\_score (semsim.wntest.SemanticSimilarityResult attribute)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.SemanticSimilarityResult.sem_sim_score}\pysigline{\bfcode{sem\_sim\_score}}
\emph{number}

The semantic similarity score between unknown\_synset and known\_synset

\end{fulllineitems}


\end{fulllineitems}

\index{filter\_results() (in module semsim.wntest)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.filter_results}\pysiglinewithargsret{\code{semsim.wntest.}\bfcode{filter\_results}}{\emph{results\_list}, \emph{threshold}}{}
Returns a filtered list of the results of the given list based on the given semantic similarity score threshold

Given a list of {\hyperref[wntest:semsim.wntest.SemanticSimilarityResult]{\emph{\code{SemanticSimilarityResult}}}} objects and a threshold value, filters the list removing result objects with semantic similarity scores less than the threshold. Returns the filtered list.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{results\_list}} (\emph{list}) -- The list of {\hyperref[wntest:semsim.wntest.SemanticSimilarityResult]{\emph{\code{SemanticSimilarityResult}}}} objects to be filtered

\item {} 
\textbf{\texttt{threshold}} (\emph{number}) -- The semantic similarity score threshold at which results with a score lower than this threshold will be removed from C\{results\_list\}

\end{itemize}

\item[{Returns}] \leavevmode
The filtered list of C\{SemanticSimilarityResult\} objects

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{output\_results() (in module semsim.wntest)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.output_results}\pysiglinewithargsret{\code{semsim.wntest.}\bfcode{output\_results}}{\emph{results\_list}, \emph{output\_filename}}{}
Prints the given list of \code{SemanticSimilarityResult} objects to a CSV file

Given a list of \code{SemanticSimilarityResult} objects and a .csv filename, writes the values of the result objects to specified file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{results\_list}} (\emph{list}) -- The list of \code{SemanticSimilarityResult} objects to be printed to the CSV file

\item {} 
\textbf{\texttt{output\_filename}} (\emph{str}) -- The name of the CSV file to be written to

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_results() (in module semsim.wntest)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.process_results}\pysiglinewithargsret{\code{semsim.wntest.}\bfcode{process\_results}}{\emph{results\_list}}{}
Sorts a list of \code{SemanticSimilarityResult} objects in descsending order by semantic similarity score
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{results\_list}} (\emph{list}) -- The list of \code{SemanticSimilarityResult} objects to be sorted

\item[{Returns}] \leavevmode
The sorted list of \code{SemanticSimilarityResult} objects

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{sem\_sim\_test2() (in module semsim.wntest)}

\begin{fulllineitems}
\phantomsection\label{wntest:semsim.wntest.sem_sim_test2}\pysiglinewithargsret{\code{semsim.wntest.}\bfcode{sem\_sim\_test2}}{\emph{known\_words\_filename}, \emph{unknown\_words\_filename}, \emph{**kwargs}}{}
Tests semantic similarity mapping from unknown words to known words. Synsets of the unknown words are not known in advance and those of the known words are determined in advance.

Accepts a CSV file of known words paired with their assumed WordNet synset and a text file of unknown words (with one word per line). Each unknown word is matched up with the known word that it is most semantically similar to. ``Known'' words are words that LILI has been preprogrammed to recognize or respond to in some way, while ``unknown'' words are those that LILI does not understand by default. Semantic similarity measures are made using WordNet and attempt to allow LILI to understand an open vocabulary beyond the words and phrases it has been preprogrammed to respond to. This test returns a list of {\hyperref[wntest:semsim.wntest.SemanticSimilarityResult]{\emph{\code{SemanticSimilarityResult}}}} objects to store the results of the test for each unknown word.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{known\_words\_filename}} (\emph{str}) -- The filename of the CSV file containing known words paired with their assumed synsets

\item {} 
\textbf{\texttt{unknown\_words\_filename}} (\emph{str}) -- The filename of the text file containing unknown words

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Kwargs:}] \leavevmode
pos (str): The part of speech of the words to be evaluated. Can have the values ``verb'', ``noun'', ``adj'', or ``adv''. If neither of these values are used or no value is provided, searching the synsets of the unknown word will not be filtered by part of speech, resulting in more processing time and potentially less accurate results

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The sorted list of \code{SemanticSimilarityResult} objects

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}



\chapter{interpreter module}
\label{interpreter:interpreter-module}\label{interpreter::doc}\label{interpreter:module-interpreter.interpreter}\index{interpreter.interpreter (module)}\index{binary\_search\_actions() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.binary_search_actions}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{binary\_search\_actions}}{\emph{target}, \emph{pool}}{}
Binary search to find a \emph{target} word in a \emph{pool} of possibilities.

This binary search is used to find a \emph{target} word with fast performance even with a large search \emph{pool}. It is implemented recursively to provide a simpler implementation. It assumes that the known actions list is sorted in descending (A to Z) order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{target}} (\emph{str}) -- The word to search for

\item {} 
\textbf{\texttt{pool}} (\emph{list}) -- A list of tuples (\emph{str}, \emph{int}) - the first value of each tuple is the word to compare agains - the second value in each tuple is an index value that corresponds to a set of synonymous actions

\end{itemize}

\item[{Returns}] \leavevmode
The index of the found word's corresponding set of synonymous actions - returns -1 if no match is found

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_action\_structures() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.build_action_structures}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{build\_action\_structures}}{\emph{filename}}{}
Given a filename that contains a list of known main actions, generates the data structures needed to interpret commands.

Opens a file of known actions, where each action set is represented on one line, and each word contained in that action set is separated by a comma (if there are multiple words in that set). For each word in this file, a tuple is generated that contains that word along with the line number it is found on in the file (starting with 0). That line number value is the main action's index, which maps the word to it's set of synonymous actions. This tuple is then appended to the list of known actions. This list is sorted by A-Z order before it is returned to prepare it for binary search operations. A list of object extractor functions is created to correspond to the main action indices to be called later on. For each line, another function is added to the extractor function list. To determine the name of the extractor function to be added next, the first word in the action set (effectively the first word in the current line) is appended to the end of the string ``object\_dict\_''. Once the function name string is built, the function is retreived from the extractor module and is appended to the extractor function list.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} (\emph{str}) -- The path (or filename if in the current directory) of the file that contains the list of known actions

\item[{Returns}] \leavevmode
A tuple containing the two list structures needed to interpret sentences. The first list is the sorted list of known actions coupled with their aciton index values. The second list is a list of object extractor functions whose list indices correspond with the appropriate action index

\item[{Return type}] \leavevmode
(list, list)

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This function only needs to run when the file is updated. It should not be run every time a new command needs to be interpreted.
\end{notice}

\end{fulllineitems}

\index{extract\_action() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.extract_action}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{extract\_action}}{\emph{sent}, \emph{known\_actions}}{}
Finds the main action that LILI can respond to given a tokenized command sentence.

The main action is most likely one of the first couple of words of the command, so the sentence is processed from first to last word. Each word in the sentence is searched for in an array of known actions. The first word that is found in the known actions array is determined to be the main action, and processing ends. A binary search algorithm is used to search for the word to keep processing time short even with large lists of known actions. A tuple that contains two values is returned. The first value is an index value that corresponds to the set of words that the found word maps to. The second value is an index value representing the position of the found word in the sentence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sent}} (\emph{list}) -- A list containing the tokenized sentence

\item {} 
\textbf{\texttt{known\_actions}} (\emph{list}) -- A list of tuples, each containing the string of an action and an index value of the set of actions it corresponds to

\end{itemize}

\item[{Returns}] \leavevmode
Tuple - first int is an index value that maps the found word to the other actions it is synonymous with - second int is an index value representing the position of the found word in the given sentence - Returns (-1, 0) if no main action is found

\item[{Return type}] \leavevmode
(int, int)

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_json() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.generate_json}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{generate\_json}}{\emph{action}, \emph{object\_dict}}{}
Returns a JSON string representation of an object dictionary with an entry for the main action's index.

First adds the main action and its index to the object dictionary, then uses the json module to dump the final dictionary into a JSON string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{action}} (\emph{int}) -- The index of the action that corresponds to its synonym set

\item {} 
\textbf{\texttt{object\_dict}} (\emph{dict}) -- An object dictionary to be converted to a JSON string

\end{itemize}

\item[{Returns}] \leavevmode
A JSON string representation of the object dictionary and the main action index

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_object\_dict() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.generate_object_dict}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{generate\_object\_dict}}{\emph{sent}, \emph{action\_tuple}, \emph{object\_extractor\_functions}}{}
Creates a dictionary of keywords from the sentence that are objects of the action to be taken.

Begins by part of speech tagging the sentence, then trimming the main action out of the sentence, so that it is not re-processed (depending on implementation details, the presence of the main action in the sentence may throw off results). Then calls upon the appropriate object extractor from the extractor module. The called object extractor is determined by the index value of the action that maps it to its set of synonymous actions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sent}} (\emph{list}) -- A list containing the tokenized sentence

\item {} 
\textbf{\texttt{action\_tuple}} (\emph{int, int}) -- Tuple - first int is an index value that maps the found word to the other actions it is synonymous with - second int is an index value representing the position of the found word in the given sentence - Returns (-1, 0) if no main action is found - same as the return value for extract\_action

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary that maps words from the sentence to types of objects that will be acted on

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{preprocess\_text() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.preprocess_text}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{preprocess\_text}}{\emph{text}}{}
Preprocesses a raw text sentence. Currently only breaks it up into tokens.

Used to do any preprocessing on a sentence in raw text. Currently, the only preprocessing operation is tokenizing the sentence into individual words and punctuation marks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{str}) -- A string containing a command sentence

\item[{Returns}] \leavevmode
A list of preprocessed tokens from the sentence

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Do not do any part of speech tagging in this function. It is a computation intensive task and may not be needed for all commands.
\end{notice}

\end{fulllineitems}

\index{test\_sent() (in module interpreter.interpreter)}

\begin{fulllineitems}
\phantomsection\label{interpreter:interpreter.interpreter.test_sent}\pysiglinewithargsret{\code{interpreter.interpreter.}\bfcode{test\_sent}}{\emph{sent\_text}}{}
Implements the order of execution (pipeline) of interpreting a sentence - utilized for checking test cases

\end{fulllineitems}



\chapter{interpreter module demo}
\label{interpreterdemo::doc}\label{interpreterdemo:interpreter-module-demo}

\section{Initial Setup}
\label{interpreterdemo:initial-setup}\label{interpreterdemo:id1}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{move}\PYG{p}{,}\PYG{n}{go}
\PYG{n}{turn}\PYG{p}{,}\PYG{n}{twist}\PYG{p}{,}\PYG{n}{rotate}
\PYG{n}{stop}
\PYG{n}{follow}
\PYG{n}{talk}\PYG{p}{,}\PYG{n}{speak}\PYG{p}{,}\PYG{n}{tell}
\PYG{n}{show}\PYG{p}{,}\PYG{n}{teach}
\end{Verbatim}

Each line in this input file represents one {\hyperref[terms:action-set]{\emph{\DUspan{}{action set}}}}. All {\hyperref[terms:action]{\emph{\DUspan{}{actions}}}} in an set are recognized as having the same meaning and will be interpreted and executed by LILI in the same exact way. For example, \emph{show} and \emph{teach} are considered synonyms since they are in the same action set. Therefore the commands \emph{Show me how to wash my hands} and \emph{Teach me how to wash my hands} have the exact same meaning to the interpreter.

Each action set has an {\hyperref[terms:action-set-index]{\emph{\DUspan{}{action set index value}}}}, which is calculated as the line number the set is found on minus 1.
\begin{itemize}
\item {} 
For example:
\begin{itemize}
\item {} 
\emph{{[}move, go{]}} has an action set index of 0

\item {} 
\emph{{[}turn, twist, rotate{]}} has an action set index of 1

\end{itemize}

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{interp}\PYG{o}{.}\PYG{n}{build\PYGZus{}action\PYGZus{}structures}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{./source/known\PYGZus{}actions.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{known\PYGZus{}actions} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{known\PYGZus{}actions}

\PYG{n}{object\PYGZus{}extractor\PYGZus{}functions} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{funcs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{k}{for} \PYG{n}{func} \PYG{o+ow}{in} \PYG{n}{object\PYGZus{}extractor\PYGZus{}functions}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{funcs}
\end{Verbatim}

The above code generates two important data structures in the interpretation task:
\begin{enumerate}
\item {} 
List of known actions
\begin{itemize}
\item {} 
Each element is a tuple containing the action and its action set index

\item {} 
Each tuple takes the form (\emph{action}, \emph{action\_set\_index})
\begin{itemize}
\item {} 
The \emph{action} is only used to find a specific word in the command

\item {} 
The \emph{action\_set\_index} gives actual meaning to the action

\end{itemize}

\end{itemize}

\item {} 
List of {\hyperref[terms:object-extractor-function]{\emph{\DUspan{}{object extractor functions}}}}
\begin{itemize}
\item {} 
Pulled from the {\hyperref[extractor:module-interpreter.extractor]{\emph{\code{extractor}}}} module

\item {} 
There is one function per action set

\item {} 
Each function corresponds a single action set

\item {} 
The index of each function in the list is the same as its correspond action set's index

\item {} 
The name of each function begins with \code{{}`object\_dict\textbackslash{}\_} and the first action in its corresponding action set is appended to the end

\end{itemize}

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
[(\PYGZsq{}follow\PYGZsq{}, 3), (\PYGZsq{}go\PYGZsq{}, 0), (\PYGZsq{}move\PYGZsq{}, 0), (\PYGZsq{}rotate\PYGZsq{}, 1), (\PYGZsq{}show\PYGZsq{}, 5), (\PYGZsq{}speak\PYGZsq{}, 4), (\PYGZsq{}stop\PYGZsq{}, 2), (\PYGZsq{}talk\PYGZsq{}, 4), (\PYGZsq{}teach\PYGZsq{}, 5), (\PYGZsq{}tell\PYGZsq{}, 4), (\PYGZsq{}turn\PYGZsq{}, 1), (\PYGZsq{}twist\PYGZsq{}, 1)]
[\PYGZsq{}object\PYGZus{}dict\PYGZus{}move\PYGZsq{}, \PYGZsq{}object\PYGZus{}dict\PYGZus{}turn\PYGZsq{}, \PYGZsq{}object\PYGZus{}dict\PYGZus{}stop\PYGZsq{}, \PYGZsq{}object\PYGZus{}dict\PYGZus{}follow\PYGZsq{}, \PYGZsq{}object\PYGZus{}dict\PYGZus{}talk\PYGZsq{}, \PYGZsq{}object\PYGZus{}dict\PYGZus{}show\PYGZsq{}]
\end{Verbatim}

The first line of output shows the contents of the known actions list.

The second line of output shows the name of each function in the object extractor function list. The actual function is stored as an object in the list \code{object\_extractor\_functions}, but a list of the names are printed as output here for readability. Therefore, each individual function can be called later on by indexing that list like so: \code{object\_extractor\_functions{[}\textless{}index\textgreater{}{]}(\textless{}params\textgreater{})}.

Notice that the action set index of each known action corresponds to the appropriate object extractor. For example, the object extractor for \emph{talk}, \emph{speak}, and \emph{tell} are in the action set with an index of 4 and their object extractor can be accessed at index 4 (the 5th element) of \code{object\_extractor\_functions}.

Also notice that the name of the extractor functions begin with \code{"object\_dict\textbackslash{}\_"} and end with the first action of its corresponding action set. This concept is important to maintainability of the system. When new action sets are added to the input file, their indices are generated automatically, and the extractor functions are automatically placed in the correct order, as long as the first action of each set matches the suffix of the corresponding extractor function. Thus, the maintainer does not need to be concerned with the order of function declarations or lines in the input file.


\section{Preprocessing and Action Detection}
\label{interpreterdemo:preprocessing-and-action-detection}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sent\PYGZus{}text} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Teach me how to wash my hands}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{sent} \PYG{o}{=} \PYG{n}{interp}\PYG{o}{.}\PYG{n}{preprocess\PYGZus{}text}\PYG{p}{(}\PYG{n}{sent\PYGZus{}text}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{sent}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZsq{}Teach\PYGZsq{}, \PYGZsq{}me\PYGZsq{}, \PYGZsq{}how\PYGZsq{}, \PYGZsq{}to\PYGZsq{}, \PYGZsq{}wash\PYGZsq{}, \PYGZsq{}my\PYGZsq{}, \PYGZsq{}hands\PYGZsq{}]
\end{Verbatim}

The above code simply preprocesses a raw text command, which currently only involves tokenizing it.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{action\PYGZus{}tuple} \PYG{o}{=} \PYG{n}{interp}\PYG{o}{.}\PYG{n}{extract\PYGZus{}action}\PYG{p}{(}\PYG{n}{sent}\PYG{p}{,} \PYG{n}{known\PYGZus{}actions}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{action\PYGZus{}tuple}
\end{Verbatim}

The above code searches through each token (from first to last) to see if any of the words match an action in the known actions list built in the {\hyperref[interpreterdemo:initial-setup]{\emph{\DUspan{}{previous section}}}}.

\begin{Verbatim}[commandchars=\\\{\}]
(5, 0)
\end{Verbatim}

The output of this search is a tuple containing the found action's set index along with its position in the sentence in the format (\emph{action\_set\_index}, \emph{position\_in\_sent}). The action detected in the given sentence \emph{Show me how to wash my hands} is \emph{show}, which is part of the action set with index 5, grouped with the action \emph{teach}. Also, its position in the sentence is the first word, so its position index is 0. This function would yield the same exact output if it was given the sentence \emph{Teach me how to wash my hands}.


\section{Extracting Objects from the Command}
\label{interpreterdemo:extracting-objects-from-the-command}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{object\PYGZus{}dict} \PYG{o}{=} \PYG{n}{interp}\PYG{o}{.}\PYG{n}{generate\PYGZus{}object\PYGZus{}dict}\PYG{p}{(}\PYG{n}{sent}\PYG{p}{,} \PYG{n}{action\PYGZus{}tuple}\PYG{p}{,} \PYG{n}{object\PYGZus{}extractor\PYGZus{}functions}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Print dictionary values in same order every time}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{person: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{object\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{person}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{show\PYGZus{}action: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{object\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{show\PYGZus{}action}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{object\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{video\PYGZus{}title: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{object\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{video\PYGZus{}title}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

The above code extracts the objects from the command. The action set index determines which object extractor function will be applied and thus what set of rules are going to be used to extract the objects. Since the action is \emph{teach}, the first action in its action set is \emph{show}, and thus the appropriate object extractor function for this command is {\hyperref[extractor:interpreter.extractor.object_dict_show]{\emph{\code{object\_dict\_show()}}}}, which is called by indexing the \code{object\_extractor\_functions} list inside of the {\hyperref[interpreter:interpreter.interpreter.generate_object_dict]{\emph{\code{generate\_object\_dict()}}}} function.

\begin{Verbatim}[commandchars=\\\{\}]
person: me
show\PYGZus{}action: wash
object: hands
video\PYGZus{}title: wash\PYGZhy{}hands
\end{Verbatim}

The above output simply displays the values of the objects along with their keys as stored in the resulting {\hyperref[terms:object-dictionary]{\emph{\DUspan{}{object dictionary}}}}, which is stored as a Python \emph{dict}. The resulting object dictionary can be sent to another software component as a JSON string or a Python \emph{dict} and the dictionary's content and semantic labels can used to determine which tasks LILI must complete.

See the {\hyperref[extractor:module-interpreter.extractor]{\emph{\code{extractor}}}} module for a full list of object extractor functions and the rules they utilize.


\chapter{extractor module}
\label{extractor:extractor-module}\label{extractor::doc}\label{extractor:module-interpreter.extractor}\index{interpreter.extractor (module)}\index{is\_noun() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.is_noun}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{is\_noun}}{\emph{tag}}{}
Checks if a part of speech tag represents a noun. The tags ``PRP'' and those that begin with ``NN'' are considered nouns.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{tag}} (\emph{str}) -- The part of speech tag to be checked

\item[{Returns}] \leavevmode
True if the tag represents a noun, False if not

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_preposition() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.is_preposition}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{is\_preposition}}{\emph{tag}}{}
Checks if a part of speech tag represents a preposition. The tags ``TO'' and ``IN'' considered to be prepositions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{tag}} (\emph{str}) -- The part of speech tag to be checked

\item[{Returns}] \leavevmode
True if the tag represents a preposition, False if not

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_follow() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_follow}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_follow}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``follow'' as its main action

Rules:
1. The first noun encountered is always the `person'
2. The second noun (if included) is always the `place'

Objects:
`person' - The person who will be followed
`place' - The location that the person will be followed to
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic object categories

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_move() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_move}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_move}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``move'' as its main action

Rules:
1. Only the first noun is detected as an object
1. If the first noun is preced by a preposition, then it is the `place'
2. If the first noun is not preceded by a preposition, then it is the `direction'

Objects:
`place' - A location to move to
`direction' - A direction to move in
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic objects

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_show() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_show}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_show}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``show'' as its main action

Rules:
1. The verb preceded by a ``to'' is the `shown\_action'
2. The noun that is not preceded by a determiner or ``to'' is the `person'
3. The noun that is preceded either by a determiner or the `shown\_action' is the `object'

Objects:
`shown\_action' - The action that will be shown in a video
`person' - The person who will be shown the action or object
`object' - The object that is acted on in the video or a static object to be shown as a picture
`video\_title' - The title of the video to be played - it is currently generated by concatentating the `shown\_action' with the `object'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic objects

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_stop() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_stop}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_stop}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``stop'' as its main action. Currently returns an empty dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic objects - currently returns an empty dictionary under all inputs

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_talk() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_talk}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_talk}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``talk'' as its main action

Rules:
1. The noun to come after the word ``about'' is the `topic'
2. The noun to come after any preposition that is not ``about'' is the `person'
3. Other nouns will be tagged as `unknown'

Objects:
`person' - The person to talk to
`topic' - The subject to talk about
`unknown' - The role of this noun is not known
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic objects

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_dict\_turn() (in module interpreter.extractor)}

\begin{fulllineitems}
\phantomsection\label{extractor:interpreter.extractor.object_dict_turn}\pysiglinewithargsret{\code{interpreter.extractor.}\bfcode{object\_dict\_turn}}{\emph{sent}}{}
Extracts objects out of a sentence that contains ``turn'' as its main action. Currently uses the same rules as object\_dict\_move - see that method for more details
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sent}} (\emph{list}) -- A part of speech tagged list of tokens representing a sentence

\item[{Returns}] \leavevmode
A dictionary mapping key words to semantic object categories

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Terminology}
\label{terms::doc}\label{terms:terminology}\phantomsection\label{terms:action}\begin{description}
\item[{\index{action}action}] \leavevmode
A verb that corresponds to a single task that LILI can complete. For example, the action \emph{follow}, as in the command \emph{``Follow me to the kitchen''}, tells LILI to follow someone.

\end{description}
\phantomsection\label{terms:action-set}\begin{description}
\item[{\index{action set}action set}] \leavevmode
A group of {\hyperref[terms:action]{\emph{\DUspan{}{actions}}}} that have the same meaning to the interpreter. For example, the actions \emph{turn}, \emph{twist}, and \emph{rotate} comprise an action set. These three actions can be used interchangeably in the same command. The commands \emph{``Turn right''}, \emph{``Twist right''}, and \emph{``Rotate right''} will all be interpreted as the same command, all yielding the same output from LILI.

\end{description}
\phantomsection\label{terms:action-set-index}\begin{description}
\item[{\index{action set index}action set index}] \leavevmode
A positive (or zero) integer value that uniquely identifies an {\hyperref[terms:action-set]{\emph{\DUspan{}{action set}}}}.

\end{description}
\phantomsection\label{terms:object}\begin{description}
\item[{\index{object}object}] \leavevmode
A key word that must be interpreted in order for LILI to perform the correct task. In the command \emph{``Follow me''}, \emph{follow} is the {\hyperref[terms:action]{\emph{\DUspan{}{action}}}} and \emph{me} is an object because LILI must know who to follow in order to do that task as the user intends.

\end{description}
\phantomsection\label{terms:object-dictionary}\begin{description}
\item[{\index{object dictionary}object dictionary}] \leavevmode
A dictionary, a set of key-value pairs, that maps a set of {\hyperref[terms:object]{\emph{\DUspan{}{objects}}}} to semantic labels that correspond to the context and meaning of each object. In the command \emph{``Follow me''}, \emph{me} is stored as a value in an object dictionary whose key is \emph{person}.

\end{description}
\phantomsection\label{terms:object-extractor-function}\begin{description}
\item[{\index{object extractor function}object extractor function}] \leavevmode
A function that uses predetermined rules to extract {\hyperref[terms:object]{\emph{\DUspan{}{objects}}}} from commands, tags the objects with semantic labels, and generates an {\hyperref[terms:object-dictionary]{\emph{\DUspan{}{object dictionary}}}}.

\end{description}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{i}
\item {\texttt{interpreter.extractor}}, \pageref{extractor:module-interpreter.extractor}
\item {\texttt{interpreter.interpreter}}, \pageref{interpreter:module-interpreter.interpreter}
\indexspace
\bigletter{s}
\item {\texttt{semsim.wntest}}, \pageref{wntest:module-semsim.wntest}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
